@namespace Lipeg.Boot
@classname LipegParser
@using Pegasus.Parser
@using Lipeg.SDK.Tree
@using Lipeg.Runtime;
@using System.Globalization
@using System.Linq
@using System.Text.RegularExpressions
@using Microsoft.CodeAnalysis.CSharp.Syntax

start <INode>
    = _ g:grammar EOF { N(gStart, gEnd, "start", g) }

grammar <INode>
    = o:options r:rules { N(oStart, rEnd, "grammar", o, r) }

options <INode>
    = a:'options' _ '{' _ s:option<0,,_> o:'}' _ { N(aStart, oEnd, "options", NS(sStart, sEnd, s)) }

option <INode>
    = a:'@' key:identifier value:(identifier / string) o:(';' _)? { N(aStart, oEnd, "setting", key, value) }

rules <INode>
    = a:'rules' _ '{' _  r:rule<0,,_> o:'}' { N(aStart, oEnd, "rules",  NS(rStart, rEnd, r)) }

rule <INode>
    = id:identifier flags:ruleFlags '=' _ expression:expression o:';' _
      { N(idStart, oEnd, "rule", id, flags, expression) }

ruleFlags <INode>
    = f:ruleFlag<0,,_> { NS(fStart, fEnd, f) }

ruleFlag <INode> -memoize -lexical
    = '-' id:identifier { id }

expression <INode>
    = choice

choice <INode>
    = c:sequence<1,,_ '/' _>  { N(cStart, cEnd, "choice", NP(cStart, cEnd, c)) }

sequence <INode>
    = e:labeled<0,,_> { N(eStart, eEnd, "sequence", NS(eStart, eEnd, e)) }

labeled <INode> -memoize
    = id:identifier ':' _ e:prefixed { N(idStart, eEnd, "labeled", id, e) }
    / prefixed

prefixed <INode>
    = a:'&' _ e:suffix { N(aStart, eEnd, "and", e) }
    / a:'!' _ e:suffix { N(aStart, eEnd, "not", e) }
    / suffix

suffix <INode>
    = e:primary _ q:quantifier { N(eStart, qEnd, "suffix", e, q) }
    / primary

primary <INode> -memoize
    = identifier
    / literal
    / class
    / dot
    / '(' _ expression:expression _ ')' { expression }

quantifier <INode> -memoize
    = q:'?' _                                                                       { N(qStart, qEnd, "?") }
    / q:'*' _                                                                       { N(qStart, qEnd, "*") }
    / q:'+' _                                                                       { N(qStart, qEnd, "+") }
    / a:'<' _ min:integer ',' _ max:integer ',' _ delimiter:expression _ o:'>' _    { N(aStart, oEnd, "<n,n,d>", min, max, delimiter) }
    / a:'<' _ min:integer ',' _ ',' _ delimiter:expression _ o:'>' _                { N(aStart, oEnd, "<n,,d>", min, delimiter) }
    / a:'<' _ min:integer ',' _ max:integer o:'>' _                                 { N(aStart, oEnd, "<n,n>", min, max) }
    / a:'<' _ count:integer o:'>' _                                                 { N(aStart, oEnd, "<n>", count, count) }

dot <INode>
    = q:'.' _ { N(qStart, qEnd, ".") }


integer <INode> -memoize
    = d:(digit+) _ { N(dStart, dEnd, "integer", Flat(d)) }

identifier <INode> -memoize -lexical
    = name:(!digit (letter / digit / "_" / "$")+) _ { N(nameStart, nameEnd, "identifier", name) }

literal <INode> -lexical
    = v:string  { N(vStart, vEnd, "literal", v) }

string <INode>
    = s:(doubleQuotedString / singleQuotedString) { N(sStart, sEnd, "string", s) }

doubleQuotedString <INode>
  = a:'"' c:(doubleQuotedCharacter*) o:'"' _ { N(aStart, oEnd, "doubleString", NS(cStart, cEnd, c)) }

doubleQuotedCharacter <INode>
    = c:simpleDoubleQuotedCharacter     { N(cStart, cEnd, "doubleCharacter", c) }
    / c:simpleEscapeSequence            { N(cStart, cEnd, "simpleEscape", c) }
    / c:hexEscapeSequence               { c }
    / c:unicodeEscapeSequence           { c }
    / c:eolEscapeSequence               { N(cStart, cEnd, "eolEscape", c) }

simpleDoubleQuotedCharacter
    = !('"' / "\\" / eolChar) .

singleQuotedString <INode>
    = a:'\'' c:(singleQuotedCharacter*) o:'\'' _ { N(aStart, oEnd, "singleString", NS(cStart, cEnd, c)) }

singleQuotedCharacter <INode>
    = c:simpleSingleQuotedCharacter     { N(cStart, cEnd, "singleCharacter", c) }
    / c:simpleEscapeSequence            { N(cStart, cEnd, "simpleEscape", c) }
    / c:hexEscapeSequence               { c }
    / c:unicodeEscapeSequence           { c }
    / c:eolEscapeSequence               { N(cStart, cEnd, "eolEscape", c) }

simpleSingleQuotedCharacter
    = !("'" / "\\" / eolChar) .

class <INode> -lexical
    = a:'[' inv:'^'? p:(classCharacterRange / classCharacter)* o:']' _ { N(aStart, oEnd, "class", NS(pStart, pEnd, p), N(invStart, invEnd, "invert", NO(inv))) }

classCharacterRange <INode>
    = a:bracketDelimitedCharacter '-' o:bracketDelimitedCharacter { N(aStart, oEnd, "range", a, o) }

classCharacter <INode>
    = c:bracketDelimitedCharacter { N(cStart, cEnd, "single", c) }

bracketDelimitedCharacter <INode>
    = c:simpleBracketDelimitedCharacter { N(cStart, cEnd, "bracketCharacter", c) }
    / c:simpleEscapeSequence            { N(cStart, cEnd, "simpleEscape", c) }
    / c:hexEscapeSequence               { c }
    / c:unicodeEscapeSequence           { c }
    / c:eolEscapeSequence               { N(cStart, cEnd, "eolEscape", c) }

simpleBracketDelimitedCharacter
    = !("]" / "\\" / eolChar) .

simpleEscapeSequence
    = "\\" !("x" / "u" / eolChar) c:. { SimpleEsc(c) }

hexEscapeSequence <INode>
    = a:"\\x" d:(hexDigit<2,2>) { N(aStart, dEnd, "hexEscape", Flat(d)) }

unicodeEscapeSequence <INode>
    = a:'\\u{' d:(hexDigit<1,6>) o:'}' { N(aStart, oEnd, "unicodeEscape", Flat(d)) }

eolEscapeSequence
    = "\\" nl:newline { nl }

digit
    = [0-9]

hexDigit
    = [0-9a-fA-F]

letter
    = [a-zA-Z]

_ -memoize
    = (whitespace / newline / comment)*

comment -memoize
    = singleLineComment
    / multiLineComment

singleLineComment -memoize -lexical
    = "//" (!eolChar .)*

multiLineComment -lexical
    = "/*" (!"*/" .)* "*/"

newline -memoize
    = "\n"
    / "\r\n"
    / "\r"
    / "\u2028"
    / "\u2029"

eolChar
    = [\n\r\u2028\u2029]

whitespace -memoize -lexical
    = [ \t\v\f\u00A0\uFEFF\u1680\u180E\u2000-\u200A\u202F\u205F\u3000]

EOF
    = !.
    / unexpected:&. #error{ "PEG0008:" + string.Format(CultureInfo.CurrentCulture, XyzResources.PEG0008_ERROR_PARSER_UnexpectedEndOfInput, unexpected) }
