@namespace Lipeg.Boot
@classname LipegParser
@using Pegasus.Parser
@using Lipeg.SDK.Tree
@using Lipeg.Runtime;
@using System.Globalization
@using System.Linq
@using System.Text.RegularExpressions
@using Microsoft.CodeAnalysis.CSharp.Syntax

start <INode>
    = _ g:grammar EOF { N("start", g) }

grammar <INode>
    = s:settings r:rules { N("grammar", s, r) }

settings <INode>
    = s:setting<0,,_> { NS(s) }

setting <INode>
    = '@' key:identifier value:(identifier / string) (',' _)? { N("setting", key, value) }

rules <INode>
    = r:rule<0,,_> { NS(r) }

rule <INode>
    = id:identifier flags:ruleFlags '=' _ expression:expression ';' _
      { N("rule", id, flags, expression) }

ruleFlags <INode>
    = f:ruleFlag<0,,_> { NS(f) }

ruleFlag <INode> -memoize -lexical
    = '-' id:identifier { id }

expression <INode>
    = choice

choice <INode>
    = choices:sequence<1,,_ '/' _>  { N("choice", NP(choices)) }

sequence <INode>
    = elements:labeled<0,,_> { N("sequence", NS(elements)) }

labeled <INode> -memoize
    = label:identifier ':' _ expression:prefixed { N("labeled", label, expression) }
    / prefixed

prefixed <INode>
    = '&' _ e:suffix { N("and", e) }
    / '!' _ e:suffix { N("not", e) }
    / suffix

suffix <INode>
    = e:primary _ q:quantifier { N("suffix", e, q) }
    / primary

primary <INode> -memoize
    = identifier
    / literal
    / class
    / dot
    / '(' _ expression:expression _ ')' { expression }

quantifier <INode> -memoize
    = q:'?' _                                                                       { N(qStart, qEnd, "?") }
    / q:'*' _                                                                       { N(qStart, qEnd, "*") }
    / q:'+' _                                                                       { N(qStart, qEnd, "+") }
    / a:'<' _ min:integer ',' _ max:integer ',' _ delimiter:expression _ o:'>' _    { N(aStart, oEnd, "<n,n,d>", min, max, delimiter) }
    / a:'<' _ min:integer ',' _ ',' _ delimiter:expression _ o:'>' _                { N(aStart, oEnd, "<n,,d>", min, delimiter) }
    / a:'<' _ min:integer ',' _ max:integer o:'>' _                                 { N(aStart, oEnd, "<n,n>", min, max) }
    / a:'<' _ count:integer o:'>' _                                                 { N(aStart, oEnd, "<n>", count, count) }

dot <INode>
    = q:'.' _ { N(qStart, qEnd, ".") }


integer <INode> -memoize -lexical
    = d:(digit+) _ { N(dStart, dEnd, "integer", NP(d)) }

identifier <INode> -memoize -lexical
    = name:(!digit (letter / digit / "_" / "$")+) _ { N(nameStart, nameEnd, "identifier", name) }

literal <INode> -lexical
    = v:string  { N(vStart, vEnd, "literal", v) }

string <INode>
    = s:(doubleQuotedString / singleQuotedString) { N(sStart, sEnd, "string", s) }

doubleQuotedString <INode>
  = a:'"' chars:(doubleQuotedCharacter*) o:'"' _ { N(aStart, oEnd, "dstring", NS(chars)) }

doubleQuotedCharacter <INode>
    = c:simpleDoubleQuotedCharacter { N(cStart, cEnd, "doubleCharacter", c) }
    / c:simpleEscapeSequence        { N(cStart, cEnd, "simpleEscape", c) }
    / c:hexEscapeSequence           { N(cStart, cEnd, "hexEscape", c) }
    / c:unicodeEscapeSequence       { N(cStart, cEnd, "unicodeEscape", c) }
    / c:eolEscapeSequence           { N(cStart, cEnd, "eolEscape", c) }

simpleDoubleQuotedCharacter
    = !('"' / "\\" / eolChar) .

singleQuotedString <INode>
    = '\'' chars:(singleQuotedCharacter*) '\'' _ { NS(chars) }

singleQuotedCharacter <INode>
    = c:simpleSingleQuotedCharacter { N(cStart, cEnd, "singleCharacter", c) }
    / c:simpleEscapeSequence        { N(cStart, cEnd, "simpleEscape", c) }
    / c:hexEscapeSequence           { N(cStart, cEnd, "hexEscape", c) }
    / c:unicodeEscapeSequence       { N(cStart, cEnd, "unicodeEscape", c) }
    / c:eolEscapeSequence           { N(cStart, cEnd, "eolEscape", c) }

simpleSingleQuotedCharacter
    = !("'" / "\\" / eolChar) .

class <INode> -lexical
    = a:'[' inv:'^'? parts:(classCharacterRange / classCharacter)* o:']' _ { N(aStart, oEnd, "class", NS(parts), N(invStart, invEnd, "invert", NO(inv))) }

classCharacterRange <INode>
    = a:bracketDelimitedCharacter '-' o:bracketDelimitedCharacter { N(aStart, oEnd, "range", a, o) }

classCharacter <INode>
    = c:bracketDelimitedCharacter { N(cStart, cEnd, "single", c) }

bracketDelimitedCharacter <INode> -memoize
    = c:simpleBracketDelimitedCharacter { N(cStart, cEnd, "bracketCharacter", c) }
    / c:simpleEscapeSequence            { N(cStart, cEnd, "simpleEscape", c) }
    / c:hexEscapeSequence               { N(cStart, cEnd, "hexEscape", c) }
    / c:unicodeEscapeSequence           { N(cStart, cEnd, "unicodeEscape", c) }
    / c:eolEscapeSequence               { N(cStart, cEnd, "eolEscape", c) }

simpleBracketDelimitedCharacter
    = !("]" / "\\" / eolChar) .

simpleEscapeSequence
    = "\\" !("x" / "u" / eolChar) c:. { SimpleEsc(c) }

hexEscapeSequence
    = "\\x" digits:(hexDigit hexDigit) { HexChar(digits) }

unicodeEscapeSequence
    = '\\u{' digits:(hexDigit hexDigit hexDigit hexDigit) '}' { HexChar(digits) }

eolEscapeSequence
    = "\\" eol:eol { eol }

digit
    = [0-9]

hexDigit
    = [0-9a-fA-F]

letter
    = [a-zA-Z]

_ -memoize
    = (whitespace / eol / comment)*

comment -memoize
    = singleLineComment
    / multiLineComment

singleLineComment -memoize -lexical
    = "//" (!eolChar .)*

multiLineComment -lexical
    = "/*" (!"*/" .)* "*/"

eol -memoize
    = "\n"
    / "\r\n"
    / "\r"
    / "\u2028"
    / "\u2029"

eolChar
    = [\n\r\u2028\u2029]

whitespace -memoize -lexical
    = [ \t\v\f\u00A0\uFEFF\u1680\u180E\u2000-\u200A\u202F\u205F\u3000]

EOF
    = !.
    / unexpected:&. #error{ "PEG0008:" + string.Format(CultureInfo.CurrentCulture, Resources.PEG0008_ERROR_PARSER_UnexpectedEndOfInput, unexpected) }
