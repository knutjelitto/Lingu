@namespace Lipeg.Boot
@classname LipegParser
@using Pegasus.Parser
@using Lipeg.SDK.Tree
@using Lipeg.Runtime;
@using System.Globalization
@using System.Linq
@using System.Text.RegularExpressions
@using Microsoft.CodeAnalysis.CSharp.Syntax

grammar <INode>
    = _ a:'grammar' _ i:identifier '{' _ o:options r:rules e:'}' _ EOF { N(aStart, eEnd, "grammar", i, o, r) }

options <INode>
    = a:'options' _ '{' _ s:option<0,,_> o:'}' _ { N(aStart, oEnd, "options", NS(sStart, sEnd, s)) }

option <INode>
    = id:identifier '=' _ value:optionValue o:(';' _)? { N(idStart, oEnd, "setting", id, value) }

optionValue <INode>
    = qualifiedIdentifier

qualifiedIdentifier <INode>
    = id:identifier<1,,'.' _> { N(idStart, idEnd, "qualifiedIdentifier", NP(idStart, idEnd, id)) }

rules <INode>
    = a:'rules' _ '{' _  r:rule<0,,_> o:'}' _ { N(aStart, oEnd, "rules",  NS(rStart, rEnd, r)) }

rule <INode>
    = a:identifier f:ruleFlags '<=' _ e:expression o:';' _ { N(aStart, oEnd, "rule", a, f, e) }
    / a:alias      f:ruleFlags '<=' _ e:expression o:';' _ { N(aStart, oEnd, "alias", a, f, e) }    

ruleFlags <INode>
    = f:ruleFlag<0,,_> { NS(fStart, fEnd, f) }

ruleFlag <INode> -memoize
    = '-' id:identifier { id }

expression <INode>
    = choice

choice <INode>
    = c:sequence<1,,_ '/' _>  { N(cStart, cEnd, "choice", NP(cStart, cEnd, c)) }

sequence <INode>
    = e:labeled<0,,_> { N(eStart, eEnd, "sequence", NS(eStart, eEnd, e)) }

labeled <INode> -memoize
    = id:identifier ':' _ e:prefix { N(idStart, eEnd, "labeled", id, e) }
    / prefix

prefix <INode>
    = a:'&' _ e:suffix { N(aStart, eEnd, "and", e) }
    / a:'!' _ e:suffix { N(aStart, eEnd, "not", e) }
    / suffix

suffix <INode>
    = e:primary _ q:quantifier { N(eStart, qEnd, "quantified", e, q) }
    / primary

primary <INode> -memoize
    = identifier
    / alias
    / stringLiteral
    / class
    / dot
    / '(' _ expression:expression ')' _ { expression }

quantifier <INode> -memoize
    = q:'?' _                                                                       { N(qStart, qEnd, "?") }
    / q:'*' _                                                                       { N(qStart, qEnd, "*") }
    / q:'+' _                                                                       { N(qStart, qEnd, "+") }

dot <INode>
    = q:'.' _ { N(qStart, qEnd, ".") }


integer <INode> -memoize
    = d:digits _ { N(dStart, dEnd, "integer", Flat(d)) }

digits
    = digit+

identifier <INode> -memoize
    = name:(!digit (letter / digit / "_" / "$")+) _ { N(nameStart, nameEnd, "identifier", name) }

stringLiteral <INode>
    = singleQuotedString

alias <INode>
    = doubleQuotedString

doubleQuotedString <INode>
  = a:'"' c:(doubleQuotedCharacter*) o:'"' _ { N(aStart, oEnd, "doubleString", NS(cStart, cEnd, c)) }

singleQuotedString <INode>
    = a:'\'' c:(singleQuotedCharacter*) o:'\'' _ { N(aStart, oEnd, "singleString", NS(cStart, cEnd, c)) }

class <INode>
    = a:'[' inv:'^'? p:(classCharacterRange / classCharacter)* o:']' _ { N(aStart, oEnd, "class", NS(pStart, pEnd, p), N(invStart, invEnd, "invert", NO(inv))) }

doubleQuotedCharacter <INode>
    = simpleDoubleQuotedCharacter
    / simpleEscapeSequence
    / hexEscapeSequence
    / unicodeEscapeSequence

singleQuotedCharacter <INode>
    = simpleSingleQuotedCharacter
    / simpleEscapeSequence
    / hexEscapeSequence
    / unicodeEscapeSequence

bracketDelimitedCharacter <INode>
    = simpleBracketDelimitedCharacter
    / simpleEscapeSequence
    / hexEscapeSequence
    / unicodeEscapeSequence

classCharacterRange <INode>
    = a:bracketDelimitedCharacter '-' o:bracketDelimitedCharacter { N(aStart, oEnd, "range", a, o) }

classCharacter <INode>
    = c:bracketDelimitedCharacter { N(cStart, cEnd, "single", c) }

simpleDoubleQuotedCharacter <INode>
    = !('"' / "\\" / eolChar) c:. { N(cStart, cEnd, "simpleCharacter", c) }

simpleSingleQuotedCharacter <INode>
    = !("'" / "\\" / eolChar) c:. { N(cStart, cEnd, "simpleCharacter", c) }

simpleBracketDelimitedCharacter <INode>
    = !(']' / '\\' / eolChar) c:. { N(cStart, cEnd, "simpleCharacter", c) }

simpleEscapeSequence <INode>
    = "\\" !("x" / "u" / eolChar) c:.   { N(cStart, cEnd, "simpleEscape", c) }

hexEscapeSequence <INode>
    = a:"\\x" d:(hexDigit<2,2>) { N(aStart, dEnd, "hexEscape", Flat(d)) }

unicodeEscapeSequence <INode>
    = a:'\\u{' d:(hexDigit<1,6>) o:'}' { N(aStart, oEnd, "unicodeEscape", Flat(d)) }

digit
    = [0-9]

hexDigit
    = [0-9a-fA-F]

letter
    = [a-zA-Z]

_ -memoize
    = (whitespace / newline / comment)*

comment -memoize
    = singleLineComment
    / multiLineComment

singleLineComment -memoize
    = "//" (!eolChar .)*

multiLineComment
    = "/*" (!"*/" .)* "*/"

newline -memoize
    = "\n"
    / "\r\n"
    / "\r"
    / "\u2028"
    / "\u2029"

eolChar
    = [\n\r\u2028\u2029]

whitespace -memoize
    = [ \t\v\f\u00A0\uFEFF\u1680\u180E\u2000-\u200A\u202F\u205F\u3000]

EOF
    = !.
    / unexpected:&. #error{ "PEG0008:" + string.Format(CultureInfo.CurrentCulture, XyzResources.PEG0008_ERROR_PARSER_UnexpectedEndOfInput, unexpected) }
