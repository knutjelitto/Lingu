grammar lipeg
{
    options
    {
        start = start;
        spacing = _;
    }
    rules
    {
        // used somewhere
        // reachable from start
        // ! zeroable
        // ! behave lexical
        start =>
            grammar EOF;
        
        // used somewhere
        // reachable from start
        // ! zeroable
        // ! behave lexical
        grammar =>
            ,('grammar') ,('{') ^(options / syntax / lexical)* ,('}');
        
        // used somewhere
        // reachable from start
        // ! zeroable
        // ! behave lexical
        options =>
            ,('options') ,('{') ^option* ,('}');
        
        // used somewhere
        // reachable from start
        // ! zeroable
        // ! behave lexical
        option =>
            identifier ,('=') optionValue ,(';');
        
        // used somewhere
        // reachable from start
        // ! zeroable
        // ! behave lexical
        optionValue =>
            qualifiedIdentifier;
        
        // used somewhere
        // reachable from start
        // ! zeroable
        // ! behave lexical
        qualifiedIdentifier =>
            identifier ^(,('.') identifier)*;
        
        // used somewhere
        // reachable from start
        // ! zeroable
        // ! behave lexical
        syntax =>
            ,('rules') ,('{') ^rule* ,('}');
        
        // used somewhere
        // reachable from start
        // ! zeroable
        // ! behave lexical
        lexical =>
            ,('lexical') ,('{') ^rule* ,('}');
        
        // used somewhere
        // reachable from start
        // ! zeroable
        // ! behave lexical
        rule =>
            identifier ,('<=') expression ,(';');
        
        // used somewhere
        // reachable from start
        // ! zeroable
        // ! behave lexical
        expression =>
            choice;
        
        // used somewhere
        // reachable from start
        // ! zeroable
        // ! behave lexical
        choice =>
            ,('/'?) sequence ^(,('/') sequence)*;
        
        // used somewhere
        // reachable from start
        // ! zeroable
        // ! behave lexical
        sequence =>
            ^aliased+;
        
        // used somewhere
        // reachable from start
        // ! zeroable
        // ! behave lexical
        aliased =>
            / prefix ':' identifier
            / prefix
            ;
        
        // used somewhere
        // reachable from start
        // ! zeroable
        // ! behave lexical
        prefix =>
            / ,('&') suffix:and
            / ,('!') suffix:not
            / ,(',') suffix:drop
            / ,('~') suffix:fuse
            / suffix
            ;
        
        // used somewhere
        // reachable from start
        // ! zeroable
        // ! behave lexical
        suffix =>
            / primary '?':zero-or-one
            / primary '?^':zero-or-one-lift
            / primary '*':zero-or-more
            / primary '*^':zero-or-more-lift
            / primary '+':one-or-more
            / primary '+^':one-or-more-lift
            / primary
            ;
        
        // used somewhere
        // reachable from start
        // ! zeroable
        // ! behave lexical
        primary =>
            / identifier
            / string
            / character-class
            / any
            / epsilon
            / ,('(') expression ,(')')
            ;
        
        // used somewhere
        // reachable from start
        // ! zeroable
        // ! behave lexical
        any =>
            ,('.');
        
        // used somewhere
        // reachable from start
        // ! zeroable
        // ! behave lexical
        epsilon =>
            / 'epsilon'
            / '\u{03B5}'
            ;
        
        // used somewhere
        // reachable from start
        // zeroable
        // ! behave lexical
        eof =>
            !.;
    }
    lexical
    {
        // used somewhere
        // reachable from start
        // ! zeroable
        // behave lexical
        identifier =>
            letter letter-or-digit* ('-' letter-or-digit+)*;
        
        // used somewhere
        // reachable from start
        // ! zeroable
        // behave lexical
        letter =>
            [a-zA-Z];
        
        // used somewhere
        // reachable from start
        // ! zeroable
        // behave lexical
        letter-or-digit =>
            [a-zA-Z0-9];
        
        // used somewhere
        // reachable from start
        // ! zeroable
        // behave lexical
        hex-digit =>
            [0-9a-fA-F];
        
        // used somewhere
        // reachable from start
        // ! zeroable
        // behave lexical
        string =>
            '\'' character* '\'';
        
        // used somewhere
        // reachable from start
        // ! zeroable
        // behave lexical
        character =>
            / !('\'' / '\\' / eol-char) .
            / escape
            / unicode
            ;
        
        // used somewhere
        // reachable from start
        // ! zeroable
        // behave lexical
        escape =>
            '\\' [0abefnrtv\-\]\\];
        
        // used somewhere
        // reachable from start
        // ! zeroable
        // behave lexical
        unicode =>
            '\\u{' hex-digit hex-digit? hex-digit? hex-digit? hex-digit? hex-digit? '}';
        
        // used somewhere
        // reachable from start
        // ! zeroable
        // behave lexical
        character-class =>
            '[' '^'? class-part* ']';
        
        // used somewhere
        // reachable from start
        // ! zeroable
        // behave lexical
        class-part =>
            / class-range
            / class-char
            ;
        
        // used somewhere
        // reachable from start
        // ! zeroable
        // behave lexical
        class-range =>
            class-char '-' class-char;
        
        // used somewhere
        // reachable from start
        // ! zeroable
        // behave lexical
        class-char =>
            / !(']' / '\\' / eol-char) .
            / escape
            / unicode
            ;
        
        // used somewhere
        // reachable from start
        // ! zeroable
        // behave lexical
        _ =>
            / whitespace
            / newline
            / comment
            *;
        
        // used somewhere
        // reachable from start
        // ! zeroable
        // behave lexical
        comment =>
            / single-line-comment
            / multi-line-comment
            ;
        
        // used somewhere
        // reachable from start
        // ! zeroable
        // behave lexical
        single-line-comment =>
            '//' (!eol-char .)*;
        
        // used somewhere
        // reachable from start
        // ! zeroable
        // behave lexical
        multi-line-comment =>
            '/*' (!'*/' .)* '*/';
        
        // used somewhere
        // reachable from start
        // ! zeroable
        // behave lexical
        newline =>
            / '\n'
            / '\r\n'
            / '\r'
            / '\u{2028}'
            / '\u{2029}'
            ;
        
        // used somewhere
        // reachable from start
        // ! zeroable
        // behave lexical
        eol-char =>
            [\n\r\u{2028}\u{2029}];
        
        // used somewhere
        // reachable from start
        // ! zeroable
        // behave lexical
        whitespace =>
            [ \t\v\f\u{00A0}\u{FEFF}\u{1680}\u{180E}\u{2000}-\u{200A}\u{202F}\u{205F}\u{3000}];
    }
}
