grammar lipeg
{
    options
    {
        start = start;
        spacing = _;
    }
    rules
    {
        start =>
            grammar _ EOF
            ;
        
        grammar =>
            _ _ _ ,_ 'grammar' _ ,_ '{' ^(options / syntax / lexical)* _ ,_ '}'
            ;
        
        options =>
            _ _ _ ,_ 'options' _ ,_ '{' ^option* _ ,_ '}'
            ;
        
        option =>
            _ _ _ identifier _ ,_ '=' optionValue _ ,_ ';'
            ;
        
        optionValue =>
            qualifiedIdentifier
            ;
        
        qualifiedIdentifier =>
            _ _ _ identifier _ ^_ _ _ (_ ,_ '.' _ identifier)*
            ;
        
        syntax =>
            _ _ _ ,_ 'rules' _ ,_ '{' ^rule* _ ,_ '}'
            ;
        
        lexical =>
            _ _ _ ,_ 'lexical' _ ,_ '{' ^rule* _ ,_ '}'
            ;
        
        rule =>
            _ _ _ identifier _ ,_ '<=' expression _ ,_ ';'
            ;
        
        // nullable
        expression =>
            choice
            ;
        
        // nullable
        choice =>
            sequence _ ^_ _ _ (_ ,_ '/' sequence)*
            ;
        
        // nullable
        sequence =>
            ^aliased*
            ;
        
        aliased =>
            / prefix _ ':' _ identifier
            / prefix
            ;
        
        prefix =>
            / _ _ _ _ (_ ,_ '&' suffix):and
            / _ _ _ _ (_ ,_ '!' suffix):not
            / _ _ _ _ (_ ,_ ',' suffix):drop
            / _ _ _ _ (_ ,_ '^' suffix):lift
            / _ _ _ _ (_ ,_ '~' suffix):fuse
            / suffix
            ;
        
        suffix =>
            / (primary _ '?'):zero-or-one
            / (primary _ '*'):zero-or-more
            / (primary _ '+'):one-or-more
            / primary
            ;
        
        primary =>
            / _ _ identifier
            / _ _ string
            / _ _ character-class
            / any
            / _ _ ,_ '(' expression _ ,_ ')'
            ;
        
        any =>
            _ _ _ ,_ '.'
            ;
    }
    lexical
    {
        // lexical
        identifier =>
            _ _ _ letter _ _ letter-or-digit* _ _ _ (_ '-' _ _ letter-or-digit+)*
            ;
        
        // lexical
        letter =>
            _ _ _ [_ a-z_ A-Z]
            ;
        
        // lexical
        letter-or-digit =>
            _ _ _ [_ a-z_ A-Z_ 0-9]
            ;
        
        // lexical
        hex-digit =>
            _ _ _ [_ 0-9_ a-f_ A-F]
            ;
        
        // lexical
        string =>
            _ _ _ '\'' _ _ character* _ '\''
            ;
        
        // lexical
        character =>
            _ / _ _ !_ (_ _ '\'' / _ _ '\\' / _ _ eol-char) _ .
            / _ _ escape
            / _ _ unicode
            ;
        
        // lexical
        escape =>
            _ _ _ '\\' _ [_ 0_ a_ b_ e_ f_ n_ r_ t_ v_ \-_ \]_ \\]
            ;
        
        // lexical
        unicode =>
            _ _ _ '\\u{' _ hex-digit _ _ hex-digit? _ _ hex-digit? _ _ hex-digit? _ _ hex-digit? _ _ hex-digit? _ '}'
            ;
        
        // lexical
        character-class =>
            _ _ _ '[' _ _ '^'? _ _ class-part* _ ']'
            ;
        
        // lexical
        class-part =>
            _ / _ _ class-range
            / _ _ class-char
            ;
        
        // lexical
        class-range =>
            _ _ _ class-char _ '-' _ class-char
            ;
        
        // lexical
        class-char =>
            _ / _ _ !_ (_ _ ']' / _ _ '\\' / _ _ eol-char) _ .
            / _ _ escape
            / _ _ unicode
            ;
        
        // nullable
        // lexical
        _ =>
            _ _ _ _ (_ _ whitespace / _ _ newline / _ _ comment)*
            ;
        
        // lexical
        comment =>
            _ / _ _ single-line-comment
            / _ _ multi-line-comment
            ;
        
        // lexical
        single-line-comment =>
            _ _ _ '//' _ _ _ (_ !_ eol-char _ .)*
            ;
        
        // lexical
        multi-line-comment =>
            _ _ _ '/*' _ _ _ (_ !_ '*/' _ .)* _ '*/'
            ;
        
        // lexical
        newline =>
            _ / _ _ '\n'
            / _ _ '\r\n'
            / _ _ '\r'
            / _ _ '\u{2028}'
            / _ _ '\u{2029}'
            ;
        
        // lexical
        eol-char =>
            _ _ _ [_ \n_ \r_ \u{2028}_ \u{2029}]
            ;
        
        // lexical
        whitespace =>
            _ _ _ [_  _ \t_ \v_ \f_ \u{00A0}_ \u{FEFF}_ \u{1680}_ \u{180E}_ \u{2000}-\u{200A}_ \u{202F}_ \u{205F}_ \u{3000}]
            ;
        
        // nullable
        // lexical
        eof =>
            _ _ _ !_ .
            ;
    }
}
